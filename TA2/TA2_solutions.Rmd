---
title: "Econometrics ü´Ä"
subtitle: "<span class=\"subtitle-text\">TA Session 2</span>"
author: "Lucia Sauer"
institute: "<em>Barcelona School of Economics</em>"
date: "2025-10-01"
output:
  html_document:
    theme: readable
    highlight: espresso #default, tango, pygments, kate, monochrome, espresso, zenburn, haddock
    df_print: paged
---


In this notebook we will review:

1. Conditional means
2. OLS in matrix algebra
3. OLS using R and Python preset functions
4. Plotting observations and fitted line
5. Numerical properties of OLS estimators



```{r}
#install libraries
# install.packages("wooldridge")
# install.packages("DT")
# install.packages("dplyr")
#install.packages("dplyr")
# install.packages("ggplot2")
```

---

# **1. Conditional Means üè°**
Using the `hprice1` dataset from the `wooldridge` package, we will explore the conditional mean of house prices given the number of bedrooms.

-  `price`     House price ($1000s)         
-  `assess`    Assessed value ($1000s)      
-  `bdrms`     Number of bedrooms           
-  `lotsize`   Lot size (square feet)       
-  `sqrft`     House size (square feet)     
-  `colonial`  =1 if home is colonial style 
-  `lprice`    Log(price)                   
-  `lassess`   Log(assess)                  
-  `llotsize`  Log(lotsize)                 
-  `lsqrft`    Log(sqrft)                   


```{r}
library(wooldridge)
#load dataset
df <-hprice1
head(df)
df[sample(nrow(df), 5), ]
```


Calculate mean of house prices conditional on number of bedrooms.

$$\hat{E} \ [price|bdrms]$$

```{r,message=FALSE}
library(dplyr)
df_grouped <- df %>% group_by(bdrms) %>% summarise(mean_price = mean(price))
df_grouped
```

## Plot the conditional mean

```{r,message=FALSE, warning=FALSE}
library(ggplot2)
#initialize the plot
ggplot() +
  # Scatter of raw data
  geom_point(data = df, aes(x = bdrms, y = price),
             color = "orange", size = 3, alpha = 0.6) +
  
  # Line plot of conditional means
  geom_line(data = df_grouped, aes(x = bdrms, y = mean_price),
            color = "orange", linewidth = 1) +
  
  # Titles and labels
  labs(
    title = expression(hat(E)*"["*price*"|"* bdrms*"]"),
    x = "Number of bedrooms",
    y = "House price"
  ) +
  
  # Styling similar to your Python example
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "grey80"),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    plot.title = element_text(size = 16, face = "bold")
  )
```

---

# 2. OLS in Matrix algebra üßÆ

Using the same dataset as before, we will estimate the following model:

$$price\_i = \beta_1 + \beta_2 \cdot bdrms_i  + \beta_3 \cdot sqrft_i + \beta_4 \cdot colonial_i + \epsilon_i $$

We can write this model in matrix form as:
$$ Y = X \beta + \epsilon $$

Where:

- $Y$ is a $n \times 1$ vector of the dependent variable (house price)
- $X$ is a $n \times k$ matrix of the independent variables (including a column of ones for the intercept)
- $\beta$ is a $k \times 1$ vector of coefficients



## 2.1 Estimate OLS coefficients using matrix algebra
```{r,message=FALSE}
#define X and y
df$intercept <- 1
X <- as.matrix(df[, c("intercept", "bdrms", "sqrft", "colonial")])
y <-df$price

#define X_tX and X_ty
X_tX <- t(X)%*%X
X_ty <- t(X)%*%y

#solve the system
beta_hat<- solve(X_tX)%*%X_ty
round(beta_hat, 2)
```

Fitted model:

$$\hat{price}_i = -21.55 + 12.49\cdot bdrms_i  + 0.13\cdot sqrft_i + 13.08\cdot colonial_i$$

where the dependent variable `price` is in **$1000s**.

## 2.2 Calculate fitted values, SSE, and $R^2$

$$\hat{y} = X \hat{\beta}$$

```{r,message=FALSE}
#Calculate y_hat
y_hat <- X %*% beta_hat
```

$$SSE = \sum_{i}^{n} (y_i - \hat{y}_i)^2 = \sum_{i}^{n} \hat{\epsilon}^2 = \hat{\epsilon}¬¥\hat{\epsilon}$$

```{r,message=FALSE}
#epsilon_hat, SSE
epsilon_hat <- y - y_hat
sse <- t(epsilon_hat) %*% epsilon_hat

cat("SSE:", sse)
```

$$R^2 = 1 - \frac{SSE}{SST}$$

where 
$$SST = \sum_{i}^{n} (y_i - \bar{y}_i)^2 = (y - \mathbf{1} \bar{y})'(y - \mathbf{1} \bar{y})$$

```{r,message=FALSE}
#SST, R^2
y_mean <- mean(y)
sst <- t(y-y_mean)%*%(y-y_mean)
r2 <- 1- (sse/sst)
cat('R2', r2)

```

Note: 

- The SSE is expressed in squared thousands of dollars.
- The R¬≤ is unitfree, and tells us that about 64% of the variation in house prices is explained by the model.

---

# **3. OLS using R and Python preset functions**

We can also estimate the same model using preset functions in Python and R.

- Python: `statsmodels` package
- R: `lm()` function

```{r,message=FALSE}
#Estimate the model with lm function 
model <- lm(price ~ bdrms + sqrft + colonial, data = df)
beta_hat <- coef(model)
y_hat <- fitted(model)
epsilon_hat <- residuals(model)

sse <- sum(epsilon_hat^2)
r2 <- summary(model)$r.squared
cat("Coefficients (betas):\n", beta_hat)

cat("\nSSE:", round(sse, 2), "\n")
cat("R^2:", round(r2, 4), "\n")
```

---

# **4. Plotting observations and fitted line**

For a simple model of $K=2$, estimate the model and plot the observations and the fitted line.

$$ price_i = \beta_1 + \beta_2 \cdot sqrft_i + \epsilon_i $$
```{r,message=FALSE}
#first we need to estimate simple model
model <- lm(price ~ sqrft, data = df)
y_hat <- fitted(model)
beta_hat <- coef(model)
beta_hat
```

```{r, warning=FALSE, message=FALSE}
eq <- paste0("price = ", round(beta_hat[1], 2), " + ", round(beta_hat[2], 2), " * sqrft")

ggplot(df, aes(x = sqrft, y = price)) +
  geom_point(color = "#00518b", size = 3, alpha = 0.6) +
  geom_abline(intercept = beta_hat[1], slope = beta_hat[2], color = "black", linewidth = 1) +
  annotate("text", x = min(df$sqrft), y = max(df$price), label = eq, hjust = 0, size = 5) +
  labs(title = "House Size and House Price", x = "House Size (Sqrft)", y = "House Price (1000 USD)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "grey80"),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    plot.title = element_text(size = 16, face = "bold")
  )
```

---

# **5. Numerical properties of OLS estimators:**


1. The sum of the residuals is zero:
$$\sum_i ^ n\hat{\epsilon}_i = \sum_i ^ n (y_i - \hat{y}_i)=0$$

on average, the residuals cancel out.

```{r,message=FALSE}
#check sum of epsilon_hat = 0
epsilon_hat <- residuals(model)
round(sum(epsilon_hat),2)
```

```{r,message=FALSE}
# Create a data frame with index and residuals
residuals_df <- data.frame(
  index = 1:length(epsilon_hat),
  residuals = epsilon_hat
)
#inspect visually this property
ggplot(residuals_df, aes(x = index, y = residuals)) +
  geom_point(color = "darkgreen", size = 3, alpha = 0.6) +   # scatter points
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") +  # horizontal line at 0
  labs(
    x = "Observation index",
    y = expression(hat(epsilon)),
    title = expression(hat(epsilon) ~ "vs Observation Index")
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "grey80"),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    plot.title = element_text(size = 16, face = "bold")
  )
```

2. OLS unit dependent, hence SSE also unit dependent

Our dependent variable is expressed in \$1000s, so let's scale it to actual dollars and see how the SSE changes.


$$1000*price = \beta X + \epsilon$$

$$\hat{\beta} ^{*} = (X'X)^{-1}X'price*1000$$
$$\hat{\beta} ^{*} = 1000\hat{\beta}$$


```{r,message=FALSE}
df$price <- df$price * 1000
model_dollars <- lm(price ~ sqrft, data = df)
beta_hat_dollars <- coef(model_dollars)
sse_dollars <- sum(residuals(model_dollars)^2)
cat("Coefficients in thousands of dollars:", round(beta_hat, 4), "\n")
cat("Coefficients in dollars:", round(beta_hat_dollars, 4), "\n")

cat("SSE in thousands of dollars:", round(sse, 2), "\n")
cat("SSE in dollars:", round(sse_dollars, 2), "\n")


```